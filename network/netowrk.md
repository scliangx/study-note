# Http / Https

> HTTP 协议一般指 HTTP（超文本传输协议）。
>
> 超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议，是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准。
>
> HTTP 是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。
>
> HTTP 是一个基于 TCP/IP 通信协议来传递数据的（HTML 文件、图片文件、查询结果等）

## 1.  HTTP

### 1.1 http协议的特点

>  1）HTTP协议是无状态的
> 就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。 

> 2）多次HTTP请求
> 在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。 
>
> 3）基于TCP协议
> HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。

### 1.2 http 协议报文组成

> HTTP报文分为请求报文和响应报文 
> 报文由三个部分组成，即**开始行、首部行和实体主体** 

1) 请求报文 
   请求报文的开始行就是请求行，所以请求报文就是由**请求行、请求头、内容实体**组成的，注意，每一行的末尾都有回车和换行，在内容实体和请求头之间另有一个空行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是键值对的形式存在的，就是字段名：值；内容实体就是要传输的数据。

​	**常见字段说明**

| 字段名          | 说明                                                         | 例子                                        |
| --------------- | ------------------------------------------------------------ | ------------------------------------------- |
|                 | 请求方法                                                     | GET                                         |
|                 | HTTP版本号                                                   | HTTP/1.1                                    |
| Host            | 指定请求的服务器的域名和端口号                               | Host:www.baidu.com                          |
| Connection      | 表示是否需要持久连接（HTTP1.1默认为长连接）                  | Connection:keep-alive(长连接),close(短连接) |
| Cache-Control   | 指定请求和响应遵循的缓存机制                                 | Cache-Control:max-age=0 或者 no-cache       |
| User-Agent      | 发出请求的用户信息（一般是浏览器的信息）                     | User-Agent: Mozilla/5.0 (Linux; X11)        |
| Accept          | 指定客户端能够接收的内容类型                                 | Accept:text/html                            |
| Accept-Encoding | 指定浏览器可以支持的web服务器返回内容压缩编码类型            | Accept-Encoding:gzip, deflate, br           |
| Accept-Language | 浏览器可接受的语言                                           | Accept-Language:zh-CN,zh                    |
| Cookie          | HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 | Cookie: $Version=1; Skin=new;               |

2. 响应报文

> 响应报文由**状态行、响应首部字段（响应头）、响应实体**组成，其中第一行是状态行，依次包含HTTP版本，状态码和状态短语组成；在一个回车换行之后是响应头，也是键值对的形式，字段名：值；然后会有一个空行也包含回车换行，之后是响应实体，就是要传输的数据。

**常见字段说明**

| 字段名            | 说明                                           | 例子                                           |
| ----------------- | ---------------------------------------------- | ---------------------------------------------- |
|                   | HTTP版本号                                     | HTTP/1.1                                       |
|                   | HTTP状态码                                     | 200 ok                                         |
| Cache-Control     | 告诉所有的缓存机制是否可以缓存那种类型         | Cache-Control:private                          |
| Connection        | 表示是否需要持久连接（HTTP1.1默认为长连接）    | Connection:keep-alive(长连接),close(短连接)    |
| Content-Encoding  | web服务器支持的返回内容压缩编码类型            | Content-Encoding:gzip                          |
| Date              | 原始服务器消息发出的时间                       | Date: Sat 30 September 2022 at 12:45:36 GMT    |
| Expires           | 响应过期的日期和时间                           | Expires: Sat 30 September 2022 at 12:46:36 GMT |
| Server            | web服务器软件名称                              | BWS/1.1                                        |
| Set-Cookie        | 设置Http Cookie                                | Set-Cookie:BDSVRTM=0;path=/                    |
| Vary              | 告诉下游代理是使用缓存响应还是从原始服务器请求 | Vary: Accept-Encoding                          |
| Transfer-Encoding | 文件传输编码                                   | Transfer-Encoding:chunked                      |

### 1.3 http请求方法

> 请求方法是客户端用来告知服务器其动作意图的方法。需要注意的是方法名区分大小写，需要用大写字母。 

- 1) GET：获取资源

     > 向特定的资源发出请求。注意：GET方法不应当被用来产生“副作用”的操作中，例如在we app中的应用，其中一个原因是GET可能会被爬虫等随意访问。 

- 2. POST：传输实体主体

> 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或对已有资源的修改。POST与GET的区别之一就是目的不同。GET的目的是获取，POST的目的是传输。

- 3) PUT 传输主体

  > PUT方法用来传输文件，向指定资源位置上传其最新内容。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。

- 4. HEAD：获得报文首部

  > HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据（响应体）。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新等信息。

- 5. DELETE：删除文件

  > DELETE方法用来删除文件，是与PUT相反的方法。DELETE要求服务器删除Request-URI所标识的资源。 

- 6. OPTIONS：询问支持的方法 

  > 因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法例如DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。 

- 7. TRACE：追踪路径 

> TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。这个方法并不常用。 

- 8. CONNECT：要求用隧道协议连接代理*

> CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL/TLS协议对通信内容加密后传输。

###  1.4 状态码

> 状态码是用来告知客户端服务器端处理请求的结果。凭借状态码用户可以知道服务器是请求处理成功、失败或者是被转发；这样出现了错误也好定位。状态码是由3位数字加原因短语组成。3位数字中的第一位是用来指定状态的类别

**常见状态码**

> **200**：请求成功，服务器已成功处理了请求 
> 300：多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 
> 301（Moved Permanently，永久移动）：请求的资源已被永久地移动到新URL，返回信息会包括新的URL，浏览器会自动定向到新URL，今后任何新的请求都应使用新的URL代替。 
> **302（临时移动）**：资源只是临时被移动，客户端应继续使用原有URL 
> **400（Bad request）**：客户端请求的语法错误，服务器无法理解 
> 401（Unauthorized）：请求需要有通过HTTP认证的认证信息 
> **403（Forbidden）**：无权限，服务器拒绝提供服务 
> **404（Not Found）**：没找到资源 
> 408（Request Timeout）：表示客户端请求超时 
> **500（Internal Server error）**：服务器内部错误 
> **503（Server Unavailable）**：服务暂不可用，表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 
> **504（Gateway Timeout）**：网关超时，是代理服务器等待应用服务器响应时的超时。 
> 505（HTTP version not supported）：服务器不支持请求的HTTP协议的版本，无法完成处理。

**301和302的区别** 

> 301：永久性转移，表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。 
> 302：暂时性转移，表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址

**重定向的意义？** 

> 重定向是为了负载均衡或导入流量，提高SEO排名（搜索引擎排名）。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于baidu.com，www.baidu.com会被搜索引擎认为是两个网站，造成每个的连接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。

## 2. HTTP和HTTPS的区别？

> 1. HTTP的URL以http开头，HTTPS的URL以https开头 
> 2. HTTP是不安全的，而HTTPS是安全的。HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。 
> 3. HTTPS协议需要到ca申请证书，HTTP无需证书。一般免费证书很少，需要交费 
> 4. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP标准端口是80，HTTPS标准端口是443。 
> 5. HTTP的连接很简单，是无状态的。

## 3. ISO七层网络模型/五层网络模型/TCPIP四层网络模型

### 3.1   ISO七层网络模型

| 名字       | 主要功能                 | 对应的典型设备                                    | 传输单位          |
| ---------- | ------------------------ | ------------------------------------------------- | ----------------- |
| 应用层     | 提供应用程序间通信       | 计算机：应用程序，如FTP、SMTP、HTTP等             | 程序级数据        |
| 表示层     | 处理数据格式、数据加密等 | 计算机：编码方式，如图像编解码、URL字段传输编码等 | 程序级数据        |
| 会话层     | 建立、维护和管理会话     | 计算机：建立会话，如session认证、断点续传         | 程序级数据        |
| 传输层     | 建立主机端到端连接       | 计算机：进程和端口                                | 数据段（segment） |
| 网络层     | 寻址和路由选择           | 网络：路由器、防火墙、多层交换机                  | 数据包（packet）  |
| 数据链路层 | 提供介质访问、链路管理等 | 网络：网卡、网桥、交换机                          | 帧（frame）       |
| 物理层     | 比特流传输               | 网络：中继器、集线器、网线和HUB                   | 比特（bit）       |



### 3.2  五层网络模型 

> 1. **应用层：**确定进程之间通信的性质以满足用户需求。应用层协议有很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等。 
> 2. **运输层：**负责主机间不同进程的通信。这一层中的协议有面向连接的TCP（传输控制协议）、无连接的UDP（用户数据报协议）；数据传输的单元称为报文段或用户数据报。 
> 3. **网络层：**负责分组交换网中不同主机间的通信。作用：发送数据时，将运输层中的报文段或用户数据报封装成IP数据报，并选择合适路由。 
> 4. **数据链路层：**负责将网络层的IP数据报组装成帧。 
> 5. **物理层：**透明地传输比特流。

### 3.3 TCP/IP分层模型（四层）

> 1. **应用层** 
>    对应于OSI七层模型的应用层和表示层。因特网的应用层协议包括：FTP（文件传输协议）、HTTP（超文本传输协议）、Telent（远程终端协议）、SMTP（简单邮件传送协议）等。 
> 2. **传输层** 
>    对应于OSI七层模型的传输层，提供两种端到端的通信服务。其中TCP协议提供可靠的数据流运输服务，UDP协议提供不可靠的用户数据报服务。 
> 3. **网间层** 
>    对应于OSI七层模型的网络层。本层包括IP协议、RIP协议，负责数据的包装、寻址和路由。同时还包含ICMP（网间控制报文协议）用来提供网络诊断信息。 
> 4. **网络接口层** 
>    提供TCP/IP协议的数据结构和实际物理硬件之间的接口



## 4. TCP/IP

### 4.1 TCP/UDP 的区别

| 类型     | TCP                                    | UDP                            |
| -------- | -------------------------------------- | ------------------------------ |
| 可靠性   | 可靠                                   | 不可靠                         |
| 连接性   | 面向连接                               | 无连接                         |
| 报文     | 面向字节流                             | 面向报文（保留报文的边界）     |
| 效率     | 传输效率低                             | 传输效率高                     |
| 双工性   | 全双工（点到点）                       | 一对一、一对多、多对一、多对多 |
| 流量控制 | 有（滑动窗口）                         | 无                             |
| 拥塞控制 | 有（慢开始、拥塞避免、快重传、快恢复） | 无                             |

### 4.12TCP 报文详解

> TCP首部的前20个字节是固定的，后面有可能还有4N字节的选项（根据需要而增加）。因此TCP首部最小长度是20个字节。 

1. 每个TCP链接都包括**源端与目的端的端口号**，各占2个字节，这两个值加上IP首部中源端IP地址与目的端IP地址构成一个TCP连接 
2. **序号**，无符号数，占4个字节。是用来标识从发端向收端发送的数据字节流。TCP是面向字节流的，它所传送的字节流中的每个字节都按顺序编号，整个要传送的字节流的起始序号是在建立连接时设置。而首部中的序号字段值是本报文段所发送的数据的第一个字节的序号。 
3. **确认号，也占4个字节**，是期望收到的对方下一个报文段的第一个数据字节的序号。 
   只有ACK的标志为1时，确认序号字段才有效，发送该字段无任何代价，因为确认序号与ACK标志一样总是TCP首部的一部分。因此当一个连接被建立之后，这个字段总是被设置，ACK标志也总是被置为1。 
4. **数据偏移，占4位（注意是位不是字节）**，它指出TCP报文段数据部分距报文段的起始部分有多远。也就是指出TCP报文段首部的长度。 
5. **保留，占6位**，保留为今后使用。

**六个控制字段，这六个字段各占一位**

6. **紧急URG(URGent)**：当URG=1时，表明“紧急指针”字段有效。它告诉系统此报文段中有紧急数据，应当尽快传送，而不要按原来的排除顺序进行传送。当你用网络程序传送数据时，忽然发现了一些问题，想取消该程序的运行，发出中断命令，这时就可以使用紧急数据，如果不这样，控制命令字符就处于TCP缓存末尾，只有在所有数据处理完毕之后，这个控制命令字符才会被交付到接收方的应用进程，这样就浪费了许多时间。

7. **确认ACK(ACKnowlegment)**：当ACK=1时，“确认”字段才有效，TCP规定，在连接建立后，所有传送的报文段，都必须报文段置1。

8. **推送PSH(PuSH)**：这个很少使用。

9. **复位RST(ReSet)**：当RST=1表明，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。RST置1用来拒绝一个非法的报文段（例如客户端在没有发送SYN报文的情况下，忽然发送一个ACk包，服务端自然会回应一RST报文进行拒绝)，或拒绝打开一个连接。因此RST位也叫做重置位或重建位。

10. **同步SYN(SYNchronization)**：在建立连接时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段；对方若同意建立连接，则在响应的报文段使用SYN=1并且ACK=1。因此当SYN=1时，表明这是一个连接请求或连接接受报文。关于TCP的连接的建立与释放请看：Tcp协议怎样建立主机之间连接——“三次握手”

11. **终止FIN(FiNis)**：用来释放一个连接，当FIN=1时，表示此报文段发送方的数据已发送完毕，并要求释放连。

12. **窗口大小：占2个字节**，窗口值范围是[0， 2的16次方-1]。窗口指的是发送报文段的一方的接收窗口（并非自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收目前允许对方发送的数据量。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。窗口值将作为接收方让发送方设置其发送窗口的依据。窗口值是经常在变化着的。

13. **检验和：占2个字节**，该字段检验的范围包括报文段的首部和数据两个部分。

14. **紧急指针：占2个字节**，只有当URG=1时，这个字段才有效。它指出本报文段中紧急数据的字节数，而紧急数据结束后就是普通数据。当所有紧急数据都处理完成时，TCP就告诉应用程序恢复到正常操作。

值得注意的是，即使窗口为0也可以发送紧急数据。

15. **选项：长度可变，最长可以达40个字节。当没有使用选项时，首部的长度为20个字节。**



 最初TCP只规定了一种选项即最大报文段长度MSS（Maximum Segment Size)，它指的是报文段中数据部分的长度。后来又陆续增加了“窗口扩大”选项、“时间戳”选项及有关“选择确认(SACK)”选项

### 4.3 TCP 的三次握手，四次挥手

#### 4.3.1 三次握手

1. **SYN_SENT：**第一次握手发生阶段，客户端发起连接。客户端调用connect，发送SYN给服务器端，然后进入SYN_SENT状态，等待服务器端确认（三次握手中的第二个报文）。如果服务器端不能连接，则直接进入CLOSED状态。 
2. **LISTEN：**服务器端等待连接的状态。服务器端经过socket, bind, listen函数之后进入此状态，开始监听客户端发过来的连接请求。此称为应用程序被动打开（等到客户端连接请求）。 
3. **SYN_RCVD：**第二次握手发生阶段，这里是服务器端接收到了客户端的SYN，此时服务器由LISTEN进入SYN_RCVD状态，同时服务器端回应一个ACK，然后再发送一个SYN即SYN+ACK给客户端。
4. **ESTABLISHED：**第三次握手发生阶段，客户端接收到服务器端的ACK包（ACK、SYN）之后，也会发送一个ACK确认包，客户端进入ESTABLISHED状态，表明客户端这边已经准备好，但TCP需要两端都准备好才可以进行数据传输。服务器端收到客户端的ACK之后会从SYN_RCVD状态转移到ESTABLISHED状态，表明服务器端也准备好进行数据传输了。这样客户端和服务器端都是ESTABLISHED状态，就可以进行后面的数据传输了。所以ESTABLISHED也可以说是一个数据传送状态。

#### 4.3.2 四次挥手

1. **FIN_WAIT_1：**第一次挥手，主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，这里以客户端执行主动关闭为例），终止连接时，发送FIN给对方，然后等待对方返回ACK。调用close()第一次挥手就进入此状态。 
2. **CLOSE_WAIT：**接收到FIN之后，被动关闭的一方进入此状态。具体动作是接收到FIN，同时发送ACK。之所以叫CLOSE_WAIT可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。因为TCP关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到FIN后也需要调用close关闭，这个CLOSE_WAIT就是处于这个状态，等待发送FIN，发送了FIN则进入LAST_ACK状态。 
3. **FIN_WAIT_2：**主动端（这里是客户端）先执行主动关闭发送FIN，然后接收到被动方返回的ACK后进入此状态。 
4. **LAST_ACK：**被动方（服务器端）发起关闭请求，由状态2进入此状态，具体动作是发送FIN给对方，同时在接收到ACK时进入CLOSED状态。 
5. **CLOSING：**两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK，同时被动方也发送了FIN，主动方接收到了FIN之后，发送ACK给被动方），主动方会由FIN_WAIT_1进入此状态，等待被动方返回ACK。 
6. **TIME_WAIT：**四次挥手操作最后都会经过这样一个状态然后进入CLOSED状态。共有三个状态会进入此状态

> - **由CLOSING进入**：同时发起关闭情况下，当主动端接收到ACK后，进入此状态，实际上这里的同时是这样的情况：客户端发起关闭请求，发送FIN之后等待服务器端回应ACK，但此时服务器端同时也发起关闭请求，也发送了FIN，并且被客户端先于ACK接收到。 
> - **由FIN_WAIT_1进入：**发起关闭后，发送了FIN，等待ACK的时候，正好被动方也发起关闭请求，发送了FIN，这是客户端接收到了先前ACK，也收到了对方的FIN（即ACK和FIN同时收到），然后发送ACK，进入TIME_WAIT状态（这里跳过了FIN_WAIT_2状态） 
>
> - **由FIN_WAIT_2进入**

#### 4.3.3 DNS解析流程

> **DNS（Domain Name System的缩写）域名系统，主要提供网站域名与IP地址的相互转化的服务，就是根据域名查出IP地址**。

**域名解析时使用UDP协议** 

> 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP 传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

**DNS服务的工作过程：** 

> 当DNS客户机需要查询程序中使用的名称时，它会查询本地DNS服务器来解析该名称。客户机发送的每条查询消息都包括3条信息，以指定服务器应回答的问题。 
>
> 1. 指定的DNS域名，表示为完全合格的域名（FQDN） 
> 2. 指定的查询类型，它可根据类型指定资源记录，或作为查询操作的专门类型。 
> 3. DNS域名的指定类别 

对于DNS服务器，它始终应指定为internet类别

## 5. IO多路复用

> 多路IO复用，有时也称为事件驱动IO，基本原理就是有个函数（如select）会不断地轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
>
> select、poll和epoll都是多路IO复用的机制。多路IO复用就通过一种机制，可以监视多个描述符，一旦某个描述符（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select、poll和epoll本质上都是同步IO，因为它们都需要在读写时间就绪后自己负责进行读写，即是阻塞的，而异步IO则无须自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。
