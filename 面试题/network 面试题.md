## 1. HTTP的常见问题

### 1.1 **GET和POST的区别** 

> 1. GET：从指定的资源请求数据，POST：向指定的资源提交要处理的数据，所以GET用于获取信息而POST是用来更新资源信息 
> 2. GET提交请求的数据实体会放在URL的后面，用？分割，参数用&连接，例如：/index.html?name=li&age=20。POST查询字符串是在POST请求的HTTP消息主体中发送。 
> 3. GET提交的数据长度有限制，因为URL长度有限制，具体的长度限制视浏览器而定，POST对数据长度没有要求。 
> 4. GET提交的数据不安全，因为参数都会暴露在URL上，不应用来处理敏感数据。 
> 5. GET请求可被缓存，可被收藏为书签，GET请求会保留在浏览器历史记录中。 
> 6. POST请求不会被缓存，不能被收藏为书签，不会保留在浏览器历史记录中

### 1.2 **POST和PUT的区别？** 

> **POST方法不是幂等的，PUT方法则有幂等性** 
> 幂等：在计算机中，一个幂等操作的特点就是其任意多次执行所产生的影响均与依次一次执行的影响相同。 
> 比如：POST在请求的时候，服务器会每次都创建一个文件，但是在PUT方法的时候只是简单地更新，而不是去重新创建，因此PUT是幂等的

### 1.3 Cookie和Session的区别和联系 

#### 1.3.1 cookie

> Cookie技术通过请求和响应报文中写入Cookie信息来控制客户端的状态。
>
> Cookie会根据响应报文里的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下客户端再向服务端发起请求时，客户端会自动在请求报文中加入Cookie值之后发送出去.
>
> 之后服务端发现客户端发送过来的Cookie后，会检查是那个客户端发送过来的请求，然后对服务器上的记录，最后得到了之前的状态信息。

#### 1.3.2 session

> Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。每个用户访问服务器都会建立一个session并自动分配一个SessionId，用于标识用户的唯一身份。
>
> session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息，当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此sesion相关联的session id, session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于session id。但是cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器

#### 1.3.3 cookie 和 session的区别

> 1. cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的；
> 2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；
> 3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
> 4. 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；

## 2. HTTP和HTTPS的区别？

> 1. HTTP的URL以http开头，HTTPS的URL以https开头 
> 2. HTTP是不安全的，而HTTPS是安全的。HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。 
> 3. HTTPS协议需要到ca申请证书，HTTP无需证书。一般免费证书很少，需要交费 
> 4. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP标准端口是80，HTTPS标准端口是443。 
> 5. HTTP的连接很简单，是无状态的。 

### 2.1 浏览器如何验证HTTPS证书的合法性？

> 1. 证书是否是信任的有效证书。**所谓信任**，就是指浏览器内置了信任的根证书，就是看看web服务器的证书是不是这些信任根发的或者信任根的二级证书机构颁发的。**所谓有效**，就是看看web服务器证书是否在有效期，是否被吊销了。 
> 2. 对方是不是上述证书的合法持有者。简单来说证明对方是否持有证书的对应私钥。验证方法两种，一种是对方签个名，我用证书验证签名；另外一种是用证书做个信封，看对方是否能解开

## 3. 同步和异步、阻塞和非阻塞、长线程和短线程的区别？

> 同步/异步主要针对client端（客户端），阻塞/非阻塞主要针对server端（服务器端）

> **同步**：发送方发出数据后，等待接收方发回响应以后才发下一个数据包的通讯方式。 
> **异步**：发送方发出数据后，不等待接收方发回响应，接着发送下个数据包的通讯方式。
>
> **阻塞调用**：是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。 
> **非阻塞调用**：指在不能立即得到结果之前，该函数不会阻塞当前线程，而会立即返回。

**HTTP的长连接和短连接本质上是TCP的长连接和短连接**

> **短连接**：一般只会在client/server间传递一次读写操作，就断开连接 
> **长连接**：在client/server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

**http1.0 / http1.1**

> 在HTTP/1.0中，默认使用的是短连接。浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就终端连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。
>
> 从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入代码：Connection:keep-alive

#### 3.1 浏览器访问Server的流程是什么？

1. **解析域名，找到主机IP** 

   > 1. 先从浏览器缓存中找，如果有缓存，直接返回IP，否则下一步 
   > 2. 缓存中无法找到IP，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回IP，否则下一步。（在计算机本地目录etc下有一个hosts文件，hosts文件中保存有域名与IP的对应解析，通常也可以修改hosts科学上网或破解软件）
   > 3. 本地和缓存中都没有，只能借助于网络。路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这是一般都能够得到相应的IP。如果还是无果，只能借助于DNS递归解析
   > 4. ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com顶级域名服务器，到baidu的域名服务器 

2. **浏览器与网站建立TCP连接** 

> 浏览器利用IP直接与网站主机通信，通过三次握手，TCP连接建立完成

3. **浏览器发起GET请求**

   >  浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL，还有User-Agent用户浏览器操作系统信息，编码等。
   >
   > **注意：**Accept-Encoding和cookies项，Accept-Encoding一般采用gzip，压缩之后传输html文件。cookies如果是首次访问，会提示服务器建立用户缓存信息，如不是，可以利用cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。

4. **显示页面或返回其他**

> 返回状态码200ok，表示服务器可以处理请求，返回报文，由于在报头中，content-type为“text/html”，浏览器以html形式渲染之后呈现，而不是下载文件。

## 4. TCP四次挥手TIME_WAIT等待两个MSL作用？ 
>  可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发送多个FIN包，在TCP/IP协议就是这样设计的，是不可避免的。主要有两个原因： 
>
> 1. 网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接。 
> 2. 同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其他的服务连接。

## 5. DNS是什么？本机使用DNS时是TCP连接还是UDP？

> **DNS（Domain Name System的缩写）域名系统，主要提供网站域名与IP地址的相互转化的服务，就是根据域名查出IP地址**。

**域名解析时使用UDP协议** 

> 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP 传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

## 6. TCP如何保证可靠性传输的？

> 1. **确认和重传：**接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传 
>    三种协议：停-等协议，后退N帧协议，选择重传协议 
> 2. **数据校验—TCP头部字段：**校验和 
>    验证的方法：将校验和与要校验的字段相加，结果为0就是正确的 
> 3. **数据合理分片和排序** 
>    UDP：IP数据报大于1500字节，大于MTU。这个时候发送方IP层就需要分片。把数据报分成若干片，使每一片都小于MTU。而接收方IP层则需要进行数据报的重组。这样就会多做许多事情，而更严重的是，由于UDP的特性，当某一片数据传送中丢失时，接收方便无法重组数据报。将导致丢弃整个UDP数据报。 
>    TCP会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。 
> 4. **流量控制：**当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。 
>    所以如果窗口值为0，发送端就会开启一个持续计数器，每个一段时间询问一下接收方。 
> 5. **拥塞控制：**当网络拥塞时，减少数据的发送。 
>    慢开始、拥塞避免、快重传、快恢复